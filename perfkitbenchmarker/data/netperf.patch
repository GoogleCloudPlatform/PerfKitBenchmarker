diff -u -r netperf-2.6.0/src/netlib.c netperf-2.6.0-patch/src/netlib.c
--- netperf-2.6.0/src/netlib.c	2012-06-19 13:32:29.000000000 -0700
+++ netperf-2.6.0-patch/src/netlib.c	2016-11-04 16:36:08.681187811 -0700
@@ -234,6 +234,11 @@
 char local_data_port[10];
 char remote_data_port[10];
 
+// See comment in netlib.h
+uint32_t think_time = 0;
+uint32_t think_time_array_size = 0;
+uint32_t think_time_run_length = 0;
+
 char *local_data_address=NULL;
 char *remote_data_address=NULL;
 
@@ -4288,9 +4293,8 @@
   for(i = 0; i < 10; i++){
     sum = 0;
     for (j = i * base; j <  (i + 1) * base; j++) {
-      sum += row[j];
+      fprintf(where,": %4d", row[j]);
     }
-    fprintf(where,": %4d", sum);
   }
   fprintf(where,"\n");
 }
diff -u -r netperf-2.6.0/src/netlib.h netperf-2.6.0-patch/src/netlib.h
--- netperf-2.6.0/src/netlib.h	2012-06-19 13:46:47.000000000 -0700
+++ netperf-2.6.0-patch/src/netlib.h	2016-11-04 16:35:53.949222735 -0700
@@ -458,6 +458,11 @@
 extern char local_data_port[10];
 extern char remote_data_port[10];
 
+// Time in nanoseconds to do pointless work after each request received
+extern uint32_t think_time;
+extern uint32_t think_time_array_size;
+extern float think_time_run_length;
+
 extern char *local_data_address;
 extern char *remote_data_address;
 
diff -u -r netperf-2.6.0/src/nettest_bsd.h netperf-2.6.0-patch/src/nettest_bsd.h
--- netperf-2.6.0/src/nettest_bsd.h	2012-06-19 13:47:09.000000000 -0700
+++ netperf-2.6.0-patch/src/nettest_bsd.h	2016-11-02 11:10:13.542697954 -0700
@@ -66,6 +66,10 @@
 
   int32_t    test_length;    /* how long is the test? */
 
+  uint32_t   think_time;               /* how long to pointlessly think on each request */
+  uint32_t   think_time_array_size;    /* size of pointer chase array for think_time work */
+  uint32_t   think_time_run_length; /* the number of contiguous elements in the think time array to sum */
+
   uint32_t   so_rcvavoid;    /* avoid copies on recv? */
   uint32_t   so_sndavoid;    /* avoid copies on send? */
   uint32_t   send_dirty_count; /* bytes to dirty before calling send */
diff -u -r netperf-2.6.0/src/nettest_omni.c netperf-2.6.0-patch/src/nettest_omni.c
--- netperf-2.6.0/src/nettest_omni.c	2012-06-19 13:33:48.000000000 -0700
+++ netperf-2.6.0-patch/src/nettest_omni.c	2016-11-04 16:37:37.472977329 -0700
@@ -3794,6 +3794,10 @@
 void
 set_omni_request_flags(struct omni_request_struct *omni_request) {
 
+      omni_request->think_time = think_time;
+      omni_request->think_time_array_size = think_time_array_size;
+      omni_request->think_time_run_length = think_time_run_length;
+
       /* we have no else clauses here because we previously set flags
 	 to zero above raj 20090803 */
       if (rem_nodelay)
@@ -5175,6 +5179,11 @@
 	  omni_request->cong_control,
 	  sizeof(local_cong_control_req));
 
+  // Extract think_time parameters
+  think_time = omni_request->think_time;
+  think_time_array_size = omni_request->think_time_array_size;
+  think_time_run_length = omni_request->think_time_run_length;
+
   /* based on what we have been told by the remote netperf, we want to
      setup our endpoint for the "data connection" and let the remote
      netperf know the situation. */
@@ -5509,6 +5518,16 @@
   addrlen = sizeof(peeraddr_in);
   memset(&peeraddr_in,0,sizeof(peeraddr_in));
 
+
+  uint32_t* think_time_array;
+  if (think_time > 0 && think_time_array_size > 0) {
+    // Create a big array to randomly traverse
+    // Don't bother intializing elements - we're just going to pointlessly sum things to force the CPU to read
+    // memory locations and do work. It should just be filled with random numbers anyway
+    think_time_array = malloc(sizeof(uint32_t) * think_time_array_size);
+    fprintf(where, "Finished creating think time array\n");
+  }
+
   /* Now it's time to start receiving data on the connection. We will */
   /* first grab the apropriate counters and then start grabbing. */
 
@@ -5676,6 +5695,27 @@
       recv_ring = recv_ring->next;
     }
 
+    if (think_time > 0) {
+      // Do think time here before we send the response
+      struct timespec think_start, cur_time;
+      uint32_t sum = 0;
+      clock_gettime(CLOCK_MONOTONIC, &think_start);
+      while (1) {
+        const uint64_t billion = 1000000000L;
+        // Get elapsed time
+        clock_gettime(CLOCK_MONOTONIC, &cur_time);
+        // Calculate the delta time
+        uint64_t diff = billion * (cur_time.tv_sec - think_start.tv_sec) + cur_time.tv_nsec - think_start.tv_nsec;
+        // Check if it's time to break out
+        if (diff > think_time)
+          break;
+        uint32_t i;
+        uint32_t run_start = rand() % think_time_array_size;
+        for (i = run_start; i < think_time_run_length; i++)
+          sum = think_time_array[i];
+      }
+    }
+
     /* if we should try to send something, then by all means, let us
        try to send something. */
     if ((omni_request->direction & NETPERF_XMIT) &&
@@ -5810,6 +5850,10 @@
     }
   }
 
+  if (think_time > 0) {
+      free(think_time_array);
+  }
+
   /* The current iteration loop now exits due to timeout or unit count
      being  reached */
   stop_timer();
@@ -7143,7 +7187,7 @@
 
 {
 
-#define OMNI_ARGS "aBb:cCd:De:fFgG:hH:i:Ij:kK:l:L:m:M:nNoOp:P:q:r:R:s:S:t:T:u:UVw:W:46"
+#define OMNI_ARGS "aBb:cCd:De:fFgG:hH:i:Ij:kK:l:L:m:M:nNoOp:P:q:r:R:s:S:t:T:u:UVw:W:X:46"
 
   extern char	*optarg;	  /* pointer to option string	*/
 
@@ -7534,6 +7578,13 @@
       /* we don't want to give-up on the failure of a connect() call */
       dont_give_up = 1;
       break;
+    case 'X':
+      break_args(optarg, arg1, arg2);
+      break_args(optarg+strlen(arg1)+1, arg2, arg3);
+      think_time = convert(arg1);
+      think_time_array_size = convert(arg2);
+      think_time_run_length = atof(arg3);
+      break;
     case 'W':
       /* set the "width" of the user space data */
       /* buffer. This will be the number of */
diff -u -r netperf-2.6.0/doc/examples/runemomniaggdemo.sh netperf-2.6.0-patch/doc/examples/runemomniaggdemo.sh
--- netperf-2.6.0/doc/examples/runemomniaggdemo.sh 2020-01-13 13:37:25.111724897 -0600
+++ netperf-2.6.0-patch/doc/examples/runemomniaggdemo.sh 2020-01-13 13:38:21.111724897 -0600
@@ -1,13 +1,20 @@
 # this is a quick and dirty migration of runemomniagg2.sh to the 
 # --enable-demo mode of aggregate testing
 function kill_netperfs {
+    echo "Killing netperfs"
     pkill -ALRM netperf
+    NETPERF_PROC=$(pgrep -P 1 -f netperf)
+
+    if [ -n "$NETPERF_PROC" ]; 
+    then
+        kill $NETPERF_PROC; 
+    fi
 
     pgrep -P 1 -f netperf > /dev/null
     while [ $? -eq 0 ]
     do
-	sleep 1
-	pgrep -P 1 -f netperf > /dev/null
+    sleep 1
+    pgrep -P 1 -f netperf > /dev/null
     done
 }
 
@@ -148,7 +155,7 @@
 
 # we assume that netservers are already running on all the load generators
 
-DURATION=120
+DURATION=60
 # do not have a uuidgen? then use the one in netperf
 MY_UUID=`uuidgen`
 # with top-of-trunk we could make this 0 and run forever
@@ -157,16 +164,16 @@
 LENGTH="-l 7200"
 OUTPUT="-o all"
 
-DO_STREAM=1;
-DO_MAERTS=1;
+DO_STREAM=0;
+DO_MAERTS=0;
 # NOTE!  The Bidir test depends on being able to set a socket buffer
 # size greater than 13 * 64KB or 832 KB or there is a risk of the test
 # hanging.  If you are running linux, make certain that
 # net.core.[r|w]mem_max are sufficiently large
-DO_BIDIR=1;
+DO_BIDIR=0;
 DO_RRAGG=1;
-DO_RR=1;
-DO_ANCILLARY=1;
+DO_RR=0;
+DO_ANCILLARY=0;
 
 # UDP_RR for TPC/PPS using single-byte transactions. we do not use
 # TCP_RR any longer because any packet losses or other matters


